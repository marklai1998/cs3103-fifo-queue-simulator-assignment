// g++ main.cpp -o SFIFO -pthread
#include <cstdlib>
#include <iostream>
#include <pthread.h>
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sstream>
#include <semaphore.h>

using namespace std;

void printTableHeader();

void printFlowRow(int, int, int);

void printPFlowRow(int, int, int);

void printServerRow(int, int, int);

void *flow(void *);

void *pflow(void *);

void *server(void *);

int seqNum;

class Queue {
public:
    Queue() {
        rear = 0;
        flowTokenAdded = 0;
        pflowTokenAdded = 0;
        tokenFetched = 0;
        tokenDropped = 0;
    };

    int getRear() { return rear; };

    int getTokenFetched() { return tokenFetched; };

    int getFlowTokenAdded() { return flowTokenAdded; };

    int getPFlowTokenAdded() { return pflowTokenAdded; };

    int getTokenDropped() { return tokenDropped; };

    void addItem(char, bool);

    char removeItem();

private:
    char queue[50];
    int rear;
    int flowTokenAdded;
    int pflowTokenAdded;
    int tokenFetched;
    int tokenDropped;
};

void Queue::addItem(char item, bool flow) {
    if (rear >= 50) {
        tokenDropped++;
        return;
    }
    queue[rear] = item;
    rear++;
    if (flow) flowTokenAdded++;
    else pflowTokenAdded++;
    seqNum = flowTokenAdded + pflowTokenAdded - 1;
}

char Queue::removeItem() {
    if (rear <= 0) return 0;
    char tmp = queue[0];
    // Move the queue forward
    for (int i = 0; i < rear - 1; i++) queue[i] = queue[i + 1];
    queue[rear] = 0;
    rear--;
    tokenFetched++;
    return tmp;
}

// Global variables
int maxToken;
int flowInterval;
Queue *queue = new Queue();
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;
sem_t sem;

int main(int argc, char *argv[]) {
    // Check user input
    if (argc != 3 || atoi(argv[1]) < 1 || atoi(argv[2]) < 1) {
        cout << "Invalid argument supplied !" << endl;
        return 0;
    }
    // Init global variable
    maxToken = atoi(argv[1]);
    flowInterval = atoi(argv[2]);
    // Init semaphore
    sem_init(&sem, 0, 0);
    // Print initial text
    cout << "The Max token is " << maxToken << " and the interval time for flow is " << flowInterval << endl;
    printTableHeader();
    // Create flow thread
    pthread_t flowT;
    pthread_create(&flowT, NULL, flow, NULL);
    // Create pflow thread
    pthread_t pflowT;
    pthread_create(&pflowT, NULL, pflow, NULL);
    // Create server thread
    pthread_t serverT;
    pthread_create(&serverT, NULL, server, NULL);
    // Wait 2 threads finish
    pthread_join(flowT, NULL);
    pthread_join(serverT, NULL);
    // Display result
    cout << "The total number of tokens that have been fetched by the server is " << queue->getTokenFetched() << endl;
    cout << "The total number of tokens that have been generated by the flow is " << queue->getFlowTokenAdded() << endl;
    cout << "The total number of tokens that have been generated by the pflow is " << queue->getPFlowTokenAdded()
         << endl;
    cout << "The total number of tokens that have been dropped by the queue is " << queue->getTokenDropped() << endl;
    return 0;
}

// Flow thread Logic
void *flow(void *) {
    while (true) {
        sleep(flowInterval);
        // Lock all resources
        pthread_mutex_lock(&lock);
        pthread_mutex_lock(&lock2);
        // Escape when token count meet the max count
        if (queue->getTokenFetched() >= maxToken) break;
        // Random token counts
        int randomCount = (rand() % 10) + 1;
        // Insert tokens
        // Generate fake char as data to simulate real queue
        for (int i = 0; i < randomCount; i++) queue->addItem((char) (rand() % 26 + 65), true);
        // Print out result
        printFlowRow(randomCount, seqNum, queue->getRear());
        // Unlock all resources
        pthread_mutex_unlock(&lock);
        pthread_mutex_unlock(&lock2);
    }
    // Force unlock when work done
    pthread_mutex_unlock(&lock);
    pthread_mutex_unlock(&lock2);
    pthread_exit(NULL);
}

// PFlow thread Logic
void *pflow(void *) {
    while (true) {
        // Listen to semaphore
        sem_wait(&sem);
        // Lock all resources
        pthread_mutex_lock(&lock);
        pthread_mutex_lock(&lock2);
        // Escape when token count meet the max count
        if (queue->getTokenFetched() >= maxToken) break;
        // Random token counts
        int randomCount = (rand() % 5) + 1;
        // Insert tokens
        // Generate fake char as data to simulate real queue
        for (int i = 0; i < randomCount; i++) queue->addItem((char) (rand() % 26 + 65), false);
        // Print out result
        printPFlowRow(randomCount, seqNum, queue->getRear());
        // Unlock all resources
        pthread_mutex_unlock(&lock);
        pthread_mutex_unlock(&lock2);
    }
    // Force unlock when work done
    pthread_mutex_unlock(&lock);
    pthread_mutex_unlock(&lock2);
    pthread_exit(NULL);
}

// Server thread Logic
void *server(void *) {
    while (true) {
        sleep(2);
        // Lock all resources
        pthread_mutex_lock(&lock);
        pthread_mutex_lock(&lock2);
        // Escape when token count meet the max count
        if (queue->getTokenFetched() >= maxToken) break;
        // Random token counts
        int randomCount = (rand() % 20) + 1;
        int remainDiff = maxToken - queue->getTokenFetched();
        int actualCount =
                randomCount > remainDiff ? remainDiff : randomCount > queue->getRear() ? queue->getRear() : randomCount;
        // Remove tokens
        // queue->removeItem() should return the data in the queue
        for (int i = 0; i < actualCount; i++) queue->removeItem();
        // Print out result
        printServerRow(queue->getRear(), actualCount, queue->getTokenFetched());
        // Notify pflow
        if (queue->getRear() == 0) sem_post(&sem);
        // Unlock all resources
        pthread_mutex_unlock(&lock);
        pthread_mutex_unlock(&lock2);
    }
    // Force unlock when work done
    pthread_mutex_unlock(&lock);
    pthread_mutex_unlock(&lock2);
    pthread_exit(NULL);
}

// Table display template
void printTableHeader() {
    printf("%-35s  %-14s  %-34s\n", "Flow", "Queue", "Server");
    printf("%-11s  %-22s  %-14s  %-13s  %-19s\n", "Token added", "Latest sequence number", "Current Length",
           "Token fetched", "Total Token fetched");
}

void printFlowRow(int tokenAdded, int latestSqNo, int currentLen) {
    ostringstream ss;
    ss << tokenAdded;
    string amount = ss.str() + "(flow)";
    printf("%-11s  %-22d  %-14d\n", amount.c_str(), latestSqNo, currentLen);
}

void printPFlowRow(int tokenAdded, int latestSqNo, int currentLen) {
    ostringstream ss;
    ss << tokenAdded;
    string amount = ss.str() + "(pflow)";
    printf("%-11s  %-22d  %-14d\n", amount.c_str(), latestSqNo, currentLen);
}

void printServerRow(int currentLen, int tokenFetched, int totalTokenFetched) {
    printf("%36s %-14d  %-13d  %-19d\n", "", currentLen, tokenFetched, totalTokenFetched);
}